{"name":"Pyvalid","tagline":"Python values validator.","body":"# pyvalid\r\n\r\n\r\nPython validation tool, which is used for checking function's input parameters and return values.\r\nThis module can be very helpful on the develop stage of the project, when control for accepted and returned function values is a one of most important things.\r\n\r\nModule consists of two decorators: `accepts` and `returns`.\r\n\r\n\r\n#### `accepts(*accepted_arg_values)`\r\nA decorator for validating types and values of input parameters of a given function.\r\nYou can pass the set of accepted types and values or validation function as decorator's input parameters.\r\nValidation process can raise the following exceptions:\r\n* `pyvalid.InvalidArgumentNumberError` — when the number or position of arguments supplied to a function is incorrect.\r\n* `pyvalid.ArgumentValidationError` — when the type of an argument to a function is not what it should be.\r\n\r\n\r\n#### `returns(*accepted_returns_values)`\r\nA decorator for validating the return value of a given function.\r\nYou can pass the set of accepted types and values or validation function as a decorator's input parameters.\r\nValidation process can raise `pyvalid.InvalidReturnType` when the return value is not in the collection of supported values and types.\r\n\r\n\r\n## How to install\r\n\r\nWith PyPI: `pip install -U pyvalid`  \r\nManually: `python setup.py install`\r\n\r\n\r\n### Example of usage\r\n\r\nFunction `calc` in example below has next limitations:\r\n* Can return only int or float value;\r\n* First parameter must be only of type str;\r\n* Second parameter must be of type int or equals to 2.0;\r\n* Third parameter must be of type int or float.\r\n\r\n\r\n```\r\nfrom pyvalid import accepts, returns\r\n\r\n\r\n@returns(int, float)\r\n@accepts(str, (int, 2.0), (int, float))\r\ndef calc(operator, val1, val2, val3):\r\n    expression = '{v1} {op} {v2} {op} {v3}'.format(\r\n        op=operator,\r\n        v1=val1, v2=val2, v3=val3\r\n    )\r\n    return eval(expression)\r\n\r\n\r\n# Output: 24.\r\nprint(calc('*', 2, 3, 4))\r\n\r\n# Output: 24.0.\r\nprint(calc(operator='*', val1=2, val2=3.0, val3=4))\r\n\r\n# Output: 24.0.\r\nprint(calc('*', 2.0, 3, 4))\r\n\r\n# Raise pyvalid.ArgumentValidationError exception,\r\n# because second argument has unsupported value.\r\nprint(calc('*', 3.14, 3, 4))\r\n\r\n\r\n# Raise pyvalid.InvalidReturnType exception,\r\n# because returns value is of type str.\r\nprint(calc('*', 2, 3, '\"4\"'))\r\n```\r\n\r\nHere is an example of usage `pyvalid` module in context of classes.\r\nPay attention to the method `connect` of the class `SqlDriver`.\r\nThis method is a good demonstration of usage `accepts` decorator for functions with keyword arguments.\r\n\r\n```\r\nfrom pyvalid import accepts, returns\r\nfrom collections import Iterable\r\n\r\n\r\nclass SqlDriver(object):\r\n\r\n    @returns(bool)\r\n    @accepts(object, host=str, port=int, usr=str, pwd=str, db=[str, None])\r\n    def connect(self, **kwargs):\r\n        connection_string = \\\r\n            'tsql -S {host} -p {port} -U {usr} -P {pwd} -D {db}'.format(**kwargs)\r\n        try:\r\n            print('Establishing connection: \"{}\"'.format(connection_string))\r\n            # Create connection..\r\n            success = True\r\n        except:\r\n            success = False\r\n        return success\r\n\r\n    @returns(bool)\r\n    def close(self):\r\n        try:\r\n            print('Closing connection')\r\n            # Close connection..\r\n            success = True\r\n        except:\r\n            success = False\r\n        return success\r\n\r\n    @returns(None, dict)\r\n    @accepts(object, str, Iterable)\r\n    def query(self, sql, params=None):\r\n        try:\r\n            query_info = 'Processing request \"{}\"'.format(sql)\r\n            if params is not None:\r\n                query_info += ' with following params: ' + ', '.join(params)\r\n            print(query_info)\r\n            # Process request..\r\n            data = dict()\r\n        except:\r\n            data = None\r\n        return data\r\n\r\n\r\nsql_driver = SqlDriver()\r\n\r\nconn_params = {\r\n    'host': '8.8.8.8',\r\n    'port': 1433,\r\n    'usr': 'admin',\r\n    'pwd': 'Super_Mega_Strong_Password_2000',\r\n    'db': 'info_tech'\r\n}\r\nsql_driver.connect(**conn_params)\r\n\r\nsql = r'SELECT * FROM ProgrammingLang'\r\npl = sql_driver.query(sql)\r\n\r\nsql = r'SELECT * FROM ProgrammingLang WHERE name=?'\r\npython_pl = sql_driver.query(sql, ('Python',))\r\n\r\nsql_driver.close()\r\n```\r\n\r\nFollowing example with class `User` will show you how to use `pyvalid` module to validate some value with using validation function.\r\n```\r\nfrom pyvalid import accepts\r\n\r\n\r\nclass User(object):\r\n\r\n    class Validator(object):\r\n\r\n        unsafe_passwords = [\r\n            '111111', '000000', '123123',\r\n            '123456', '12345678', '1234567890',\r\n            'qwerty', 'sunshine', 'password',\r\n        ]\r\n\r\n        @classmethod\r\n        def login_checker(cls, login):\r\n            is_valid = isinstance(login, str) and 1 <= len(login) <= 16\r\n            if is_valid:\r\n                for reg_user in User.registered:\r\n                    if login == reg_user.login:\r\n                        is_valid = False\r\n                        break\r\n            return is_valid\r\n\r\n        @classmethod\r\n        def password_checker(cls, password):\r\n            is_valid = isinstance(password, str) and \\\r\n                (6 <= len(password) <= 32) and \\\r\n                (password not in cls.unsafe_passwords)\r\n            return is_valid\r\n\r\n    registered = list()\r\n\r\n    def __init__(self, login, password):\r\n        self.__login = None\r\n        self.login = login\r\n        self.__password = None\r\n        self.password = password\r\n        User.registered.append(self)\r\n\r\n    @property\r\n    def login(self):\r\n        return self.__login\r\n\r\n    @login.setter\r\n    @accepts(object, Validator.login_checker)\r\n    def login(self, value):\r\n        self.__login = value\r\n\r\n    @property\r\n    def password(self):\r\n        return self.__password\r\n\r\n    @password.setter\r\n    @accepts(object, Validator.password_checker)\r\n    def password(self, value):\r\n        self.__password = value\r\n\r\n\r\nuser = User('admin', 'Super_Mega_Strong_Password_2000')\r\n\r\n# Output: admin Super_Mega_Strong_Password_2000\r\nprint(user.login, user.password)\r\n\r\n# Raise pyvalid.ArgumentValidationError exception,\r\n# because User.Validator.password_checker method\r\n# returns False value.\r\nuser.password = 'qwerty'\r\n\r\n# Raise pyvalid.ArgumentValidationError exception,\r\n# because User.Validator.login_checker method\r\n# returns False value.\r\nuser = User('admin', 'Super_Mega_Strong_Password_2001')\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}